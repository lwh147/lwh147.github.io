Markdown文件编写规范：

md编写规范：

1. 无需在目录中出现的小标题不需要加粗
2. 行内代码使用 ` ` ，其他使用 加粗 或 【】或 “”格式强调
3. 步骤描述不标注第几步，阅读顺序就是如此
4. 避免使用有序列表，阅读顺序就是如此，而且md的有序列表比较难看
5. 最多使用一级无序列表，简单，别套娃了
6. 代码块必须指定语言类型，未知的一律使用text

开发规范/注意事项：

对 查询结果对象 或者 参数对象 进行处理时（比如调用obj.method()时）需要考虑对象是否为空
将变量声明尽可能提取到循环语句之外执行以重复使用变量，减少资源消耗
使用Spring内置的BeanUtils，性能比其它工具类高
谨慎使用BeanCopy，需要注意的有两点：符合拷贝条件的源对象值为null的属性也会被拷贝；浅拷贝
事务性，同一接口中涉及多次数据库操作，部分成功的情况下遇到有一个失败的情况则需要抛出异常进行回滚
凡是操作失败或结果异常的都通过抛异常结束程序执行，走异常流程返回，异常本来就是处理错误情况的，正常返回失败无意义
检查问题时，对于确定没有问题的地方，应优先考虑与他人或官方文档 不同 的地方，经过多次实践已经证明，这种情况往往是自己的错
正常开发使用@Slf4j时不要指定其topic属性，会覆盖日志系统中当前类所在包名导致配置的日志输出级别不生效
使用缓冲数组读取或写入数据时，缓冲器大小设置为8192（不论是按char缓存还是按byte缓存）

异常处理规范：

首先，异常分为 业务异常 和 非业务异常
    针对非业务异常，业务代码不做处理，发生异常时统一由全局异常处理器去拦截处理
    针对业务异常，统一异常不需要过多处理（再封装等），打印相关信息并记录日志即可
其次，出现异常时的日志记录应由全局异常完成，业务代码只管抛出即可，禁止越俎代庖出现重复打印异常信息的情况
全局异常处理器处理异常时应将空指针异常、数据库操作相关异常、远程调用相关异常、参数校验相关异常等（包含但不限于）
经常出现的异常做进一步封装处理，其余异常可不做分类统一认为是其它异常
自定义异常类三属性：在哪里（事发地），是什么（事发现场），为什么（原因）
source（服务名）,  code（异常编码）, message（异常信息）, causation（原因）
其中，source字段由全局异常处理自动填充
未来考虑加入traceId字段，通过zipkin生成全局唯一的异常追踪id